import React, { useState, useEffect, useCallback } from 'react';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from 'recharts';
import { 
  TrendingUp, 
  TrendingDown, 
  Activity, 
  Wallet, 
  Settings, 
  BarChart3, 
  AlertCircle, 
  Play, 
  Pause, 
  RefreshCw, 
  Send, 
  Download, 
  Copy, 
  Key, 
  Shield, 
  Eye, 
  EyeOff 
} from 'lucide-react';

const CryptoTradingBot = () => {
  const [cryptoData, setCryptoData] = useState([]);
  const [selectedCrypto, setSelectedCrypto] = useState('bitcoin');
  const [chartData, setChartData] = useState([]);
  const [balance, setBalance] = useState({ USD: 10000, crypto: {} });
  const [activeBot, setActiveBot] = useState(false);
  const [trades, setTrades] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);
  const [activeTab, setActiveTab] = useState('trading');
  const [wallet, setWallet] = useState(null);
  const [showPrivateKey, setShowPrivateKey] = useState(false);
  const [showSeedPhrase, setShowSeedPhrase] = useState(false);
  const [walletTransactions, setWalletTransactions] = useState([]);
  const [sendForm, setSendForm] = useState({ address: '', amount: '', crypto: 'bitcoin' });

  const [botConfig, setBotConfig] = useState({
    strategy: 'rsi',
    riskLevel: 'medium',
    dcaEnabled: true,
    dcaType: 'buy',
    stopLoss: 5,
    takeProfit: 10
  });

  const generateWallet = useCallback(() => {
    try {
      const generateRandomHex = (length) => {
        const array = new Uint8Array(length);
        window.crypto.getRandomValues(array);
        return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
      };

      const words = ['abandon', 'ability', 'able', 'about', 'above', 'absent', 'absorb', 'abstract', 'absurd', 'abuse', 'access', 'accident'];
      const seedPhrase = Array.from({ length: 12 }, () => words[Math.floor(Math.random() * words.length)]).join(' ');
      const privateKey = generateRandomHex(32);
      const publicKey = generateRandomHex(33);
      const address = '0x' + generateRandomHex(20);

      setWallet({
        address,
        publicKey,
        privateKey,
        seedPhrase,
        createdAt: new Date().toISOString()
      });
    } catch (err) {
      console.error('Erreur génération wallet:', err);
      setError('Erreur lors de la génération du wallet');
    }
  }, []);

  const fetchCryptoData = useCallback(async () => {
    try {
      setError(null);
      const response = await fetch(
        'https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=100&page=1&price_change_percentage=24h',
        { headers: { 'Accept': 'application/json' } }
      );
      
      if (!response.ok) {
        throw new Error('Erreur API: ' + response.status);
      }
      
      const data = await response.json();
      
      if (Array.isArray(data) && data.length > 0) {
        setCryptoData(data);
        setIsLoading(false);
      } else {
        throw new Error('Données invalides reçues');
      }
    } catch (err) {
      console.error('Erreur fetch crypto:', err);
      setError('Impossible de charger les données crypto. Utilisation de données de démo.');
      setCryptoData([
        {
          id: 'bitcoin',
          symbol: 'btc',
          name: 'Bitcoin',
          image: 'https://assets.coingecko.com/coins/images/1/small/bitcoin.png',
          current_price: 45000,
          market_cap_rank: 1,
          price_change_percentage_24h: 2.5
        },
        {
          id: 'ethereum',
          symbol: 'eth',
          name: 'Ethereum',
          image: 'https://assets.coingecko.com/coins/images/279/small/ethereum.png',
          current_price: 2500,
          market_cap_rank: 2,
          price_change_percentage_24h: -1.2
        }
      ]);
      setIsLoading(false);
    }
  }, []);

  const fetchChartData = useCallback(async (coinId) => {
    try {
      const response = await fetch(
        'https://api.coingecko.com/api/v3/coins/' + coinId + '/market_chart?vs_currency=usd&days=7&interval=hourly'
      );
      
      if (!response.ok) {
        throw new Error('Erreur chargement graphique');
      }
      
      const data = await response.json();
      
      if (data.prices && Array.isArray(data.prices)) {
        const formattedData = data.prices.map(([timestamp, price]) => ({
          time: new Date(timestamp).toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' }),
          price: parseFloat(price.toFixed(2)),
          timestamp
        }));
        setChartData(formattedData.slice(-50));
      }
    } catch (err) {
      console.error('Erreur graphique:', err);
      const demoData = Array.from({ length: 50 }, (_, i) => ({
        time: i + 'h',
        price: 45000 + Math.random() * 1000,
        timestamp: Date.now() - (50 - i) * 3600000
      }));
      setChartData(demoData);
    }
  }, []);

  useEffect(() => {
    generateWallet();
    fetchCryptoData();
    const interval = setInterval(fetchCryptoData, 60000);
    return () => clearInterval(interval);
  }, [generateWallet, fetchCryptoData]);

  useEffect(() => {
    if (selectedCrypto && cryptoData.length > 0) {
      fetchChartData(selectedCrypto);
    }
  }, [selectedCrypto, cryptoData.length, fetchChartData]);

  useEffect(() => {
    if (!activeBot || cryptoData.length === 0) return;
    
    const interval = setInterval(() => {
      const crypto = cryptoData.find(c => c.id === selectedCrypto);
      if (!crypto || !crypto.current_price) return;

      const signal = Math.random() > 0.7 ? (Math.random() > 0.5 ? 'BUY' : 'SELL') : null;
      
      if (signal === 'BUY' && balance.USD >= 100) {
        const amount = balance.USD * 0.1;
        const quantity = amount / crypto.current_price;
        
        setBalance(prev => ({
          USD: prev.USD - amount,
          crypto: {
            ...prev.crypto,
            [crypto.id]: (prev.crypto[crypto.id] || 0) + quantity
          }
        }));

        setTrades(prev => [{
          id: Date.now(),
          type: 'BUY',
          crypto: crypto.symbol.toUpperCase(),
          price: crypto.current_price,
          amount: amount,
          quantity: quantity,
          timestamp: new Date().toLocaleString('fr-FR'),
          strategy: botConfig.strategy
        }, ...prev].slice(0, 50));
      }

      if (signal === 'SELL' && (balance.crypto[crypto.id] || 0) > 0) {
        const quantity = (balance.crypto[crypto.id] || 0) * 0.5;
        const total = quantity * crypto.current_price;
        
        setBalance(prev => ({
          USD: prev.USD + total,
          crypto: {
            ...prev.crypto,
            [crypto.id]: Math.max(0, (prev.crypto[crypto.id] || 0) - quantity)
          }
        }));

        setTrades(prev => [{
          id: Date.now(),
          type: 'SELL',
          crypto: crypto.symbol.toUpperCase(),
          price: crypto.current_price,
          amount: total,
          quantity: quantity,
          timestamp: new Date().toLocaleString('fr-FR'),
          strategy: botConfig.strategy
        }, ...prev].slice(0, 50));
      }
    }, 8000);

    return () => clearInterval(interval);
  }, [activeBot, cryptoData, selectedCrypto, balance, botConfig]);

  const handleSend = () => {
    if (!sendForm.address || !sendForm.amount) {
      alert('Veuillez remplir tous les champs');
      return;
    }

    const crypto = cryptoData.find(c => c.id === sendForm.crypto);
    if (!crypto) {
      alert('Cryptomonnaie non trouvée');
      return;
    }

    const amount = parseFloat(sendForm.amount);
    const currentBalance = balance.crypto[sendForm.crypto] || 0;

    if (currentBalance < amount) {
      alert('Solde insuffisant');
      return;
    }

    const fee = amount * 0.001;
    const txHash = '0x' + Array.from({ length: 64 }, () => Math.floor(Math.random() * 16).toString(16)).join('');

    const transaction = {
      id: Date.now(),
      type: 'SEND',
      hash: txHash,
      from: wallet?.address || 'N/A',
      to: sendForm.address,
      amount: amount,
      fee: fee,
      crypto: crypto.symbol.toUpperCase(),
      price: crypto.current_price,
      valueUSD: amount * crypto.current_price,
      timestamp: new Date().toISOString(),
      status: 'confirmed',
      confirmations: 12
    };

    setBalance(prev => ({
      ...prev,
      crypto: {
        ...prev.crypto,
        [sendForm.crypto]: Math.max(0, (prev.crypto[sendForm.crypto] || 0) - (amount + fee))
      }
    }));

    setWalletTransactions(prev => [transaction, ...prev]);
    setSendForm({ address: '', amount: '', crypto: 'bitcoin' });
    alert('Transaction envoyée!\nHash: ' + txHash.substring(0, 20) + '...');
  };

  const handleReceive = (cryptoId) => {
    const crypto = cryptoData.find(c => c.id === cryptoId);
    if (!crypto) return;

    const amount = Math.random() * 0.1;
    const txHash = '0x' + Array.from({ length: 64 }, () => Math.floor(Math.random() * 16).toString(16)).join('');

    const transaction = {
      id: Date.now(),
      type: 'RECEIVE',
      hash: txHash,
      from: '0x' + Array.from({ length: 40 }, () => Math.floor(Math.random() * 16).toString(16)).join(''),
      to: wallet?.address || 'N/A',
      amount: amount,
      fee: 0,
      crypto: crypto.symbol.toUpperCase(),
      price: crypto.current_price,
      valueUSD: amount * crypto.current_price,
      timestamp: new Date().toISOString(),
      status: 'confirmed',
      confirmations: 12
    };

    setBalance(prev => ({
      ...prev,
      crypto: {
        ...prev.crypto,
        [cryptoId]: (prev.crypto[cryptoId] || 0) + amount
      }
    }));

    setWalletTransactions(prev => [transaction, ...prev]);
    alert(amount.toFixed(8) + ' ' + crypto.symbol.toUpperCase() + ' reçus!');
  };

  const copyToClipboard = (text) => {
    navigator.clipboard.writeText(text).then(
      () => alert('Copié!'),
      () => alert('Erreur de copie')
    );
  };

  const totalBalance = balance.USD + Object.entries(balance.crypto).reduce((total, [coinId, qty]) => {
    const crypto = cryptoData.find(c => c.id === coinId);
    return total + (crypto && crypto.current_price ? qty * crypto.current_price : 0);
  }, 0);

  const profit = totalBalance - 10000;
  const profitPercent = (profit / 10000) * 100;

  if (isLoading) {
    return (
      <div className="min-h-screen bg-slate-950 flex items-center justify-center">
        <div className="text-white text-xl flex items-center gap-3">
          <RefreshCw className="animate-spin" size={32} />
          Chargement des données...
        </div>
      </div>
    );
  }

  const selectedCryptoData = cryptoData.find(c => c.id === selectedCrypto);

  return (
    <div className="min-h-screen bg-slate-950 text-white p-6">
      <div className="max-w-7xl mx-auto">
        <div className="mb-6 flex items-center justify-between flex-wrap gap-4">
          <div>
            <h1 className="text-3xl font-bold flex items-center gap-3">
              <Shield className="text-blue-500" size={32} />
              Plateforme de Trading Sécurisée
            </h1>
            <p className="text-slate-400 mt-1">Wallet intégré + Trading automatisé</p>
            {error && (
              <div className="mt-2 text-yellow-500 text-sm flex items-center gap-2">
                <AlertCircle size={16} />
                {error}
              </div>
            )}
          </div>
          <div className="bg-slate-900 px-6 py-4 rounded-lg border border-slate-800">
            <div className="text-sm text-slate-400 mb-1">Balance Totale</div>
            <div className="text-2xl font-bold">${totalBalance.toFixed(2)}</div>
            <div className={`text-sm flex items-center gap-1 ${profit >= 0 ? 'text-green-500' : 'text-red-500'}`}>
              {profit >= 0 ? <TrendingUp size={16} /> : <TrendingDown size={16} />}
              {profit >= 0 ? '+' : ''}{profit.toFixed(2)} USD ({profitPercent.toFixed(2)}%)
            </div>
          </div>
        </div>

        <div className="mb-6 flex gap-2 border-b border-slate-800 overflow-x-auto">
          {[
            { id: 'trading', icon: Activity, label: 'Trading Bot' },
            { id: 'wallet', icon: Wallet, label: 'Mon Wallet' },
            { id: 'send', icon: Send, label: 'Envoyer' },
            { id: 'receive', icon: Download, label: 'Recevoir' }
          ].map(tab => (
            <button
              key={tab.id}
              onClick={() => setActiveTab(tab.id)}
              className={`px-6 py-3 font-semibold transition-colors flex items-center gap-2 whitespace-nowrap ${
                activeTab === tab.id 
                  ? 'text-blue-500 border-b-2 border-blue-500' 
                  : 'text-slate-400 hover:text-white'
              }`}
            >
              <tab.icon size={20} />
              {tab.label}
            </button>
          ))}
        </div>

        {activeTab === 'trading' && (
          <div className="grid grid-cols-1 lg:grid-cols-12 gap-6">
            <div className="lg:col-span-3 space-y-4">
              <div className="bg-slate-900 p-4 rounded-lg border border-slate-800">
                <h3 className="font-semibold mb-4 flex items-center gap-2">
                  <Settings size={20} className="text-blue-500" />
                  Configuration
                </h3>
                <div className="space-y-4">
                  <div>
                    <label className="text-sm text-slate-400 block mb-2">Stratégie</label>
                    <select 
                      value={botConfig.strategy}
                      onChange={(e) => setBotConfig({...botConfig, strategy: e.target.value})}
                      className="w-full bg-slate-800 border border-slate-700 rounded px-3 py-2 text-sm"
                    >
                      <option value="rsi">RSI</option>
                      <option value="macd">MACD</option>
                      <option value="bollinger">Bollinger Bands</option>
                    </select>
                  </div>
                  <div>
                    <label className="text-sm text-slate-400 block mb-2">Niveau de Risque</label>
                    <select 
                      value={botConfig.riskLevel}
                      onChange={(e) => setBotConfig({...botConfig, riskLevel: e.target.value})}
                      className="w-full bg-slate-800 border border-slate-700 rounded px-3 py-2 text-sm"
                    >
                      <option value="low">Faible (0.5x)</option>
                      <option value="medium">Moyen (1x)</option>
                      <option value="high">Élevé (2x)</option>
                    </select>
                  </div>
                  <button
                    onClick={() => setActiveBot(!activeBot)}
                    className={`w-full py-3 rounded font-semibold flex items-center justify-center gap-2 transition-colors ${
                      activeBot ? 'bg-red-600 hover:bg-red-700' : 'bg-green-600 hover:bg-green-700'
                    }`}
                  >
                    {activeBot ? <Pause size={20} /> : <Play size={20} />}
                    {activeBot ? 'Arrêter' : 'Démarrer'}
                  </button>
                </div>
              </div>

              <div className="bg-slate-900 p-4 rounded-lg border border-slate-800">
                <h3 className="font-semibold mb-4 flex items-center gap-2">
                  <Wallet size={20} className="text-green-500" />
                  Portefeuille
                </h3>
                <div className="space-y-3">
                  <div className="flex justify-between pb-2 border-b border-slate-800">
                    <span className="text-slate-400">USD</span>
                    <span className="font-semibold">${balance.USD.toFixed(2)}</span>
                  </div>
                  {Object.entries(balance.crypto).map(([coinId, qty]) => {
                    const crypto = cryptoData.find(c => c.id === coinId);
                    if (!crypto || qty <= 0 || !crypto.current_price) return null;
                    return (
                      <div key={coinId} className="flex justify-between text-sm">
                        <span className="text-slate-400">{crypto.symbol.toUpperCase()}</span>
                        <div className="text-right">
                          <div className="font-semibold">{qty.toFixed(6)}</div>
                          <div className="text-xs text-slate-500">${(qty * crypto.current_price).toFixed(2)}</div>
                        </div>
                      </div>
                    );
                  })}
                </div>
              </div>
            </div>

            <div className="lg:col-span-6 space-y-4">
              <div className="bg-slate-900 p-4 rounded-lg border border-slate-800">
                <div className="flex items-center justify-between mb-4 flex-wrap gap-4">
                  <div>
                    <h3 className="font-semibold flex items-center gap-2">
                      <BarChart3 size={20} className="text-purple-500" />
                      {selectedCryptoData?.name || 'Bitcoin'}
                    </h3>
                    {selectedCryptoData && (
                      <div className="mt-2 flex items-center gap-4">
                        <span className="text-2xl font-bold">
                          ${selectedCryptoData.current_price?.toFixed(2) || '0.00'}
                        </span>
                        <span className={`text-sm flex items-center gap-1 ${
                          (selectedCryptoData.price_change_percentage_24h || 0) >= 0 
                            ? 'text-green-500' : 'text-red-500'
                        }`}>
                          {(selectedCryptoData.price_change_percentage_24h || 0) >= 0 
                            ? <TrendingUp size={16} /> : <TrendingDown size={16} />}
                          {Math.abs(selectedCryptoData.price_change_percentage_24h || 0).toFixed(2)}%
                        </span>
                      </div>
                    )}
                  </div>
                  {activeBot && (
                    <div className="flex items-center gap-2 px-3 py-1 bg-green-600/20 border border-green-600 rounded text-green-500 text-sm">
                      <div className="w-2 h-2 bg-green-500 rounded-full animate-pulse" />
                      Bot Actif
                    </div>
                  )}
                </div>
                <ResponsiveContainer width="100%" height={400}>
                  <LineChart data={chartData}>
                    <CartesianGrid strokeDasharray="3 3" stroke="#334155" />
                    <XAxis dataKey="time" stroke="#64748b" tick={{ fontSize: 12 }} />
                    <YAxis stroke="#64748b" tick={{ fontSize: 12 }} domain={['auto', 'auto']} />
                    <Tooltip contentStyle={{ backgroundColor: '#1e293b', border: '1px solid #334155' }} />
                    <Line type="monotone" dataKey="price" stroke="#3b82f6" strokeWidth={2} dot={false} />
                  </LineChart>
                </ResponsiveContainer>
              </div>

              <div className="bg-slate-900 p-4 rounded-lg border border-slate-800">
                <h3 className="font-semibold mb-4">Historique des Trades</h3>
                <div className="max-h-64 overflow-y-auto space-y-2">
                  {trades.length === 0 ? (
                    <div className="text-center text-slate-500 py-8">
                      <AlertCircle className="mx-auto mb-2" size={32} />
                      Aucun trade
                    </div>
                  ) : (
                    trades.map(trade => (
                      <div key={trade.id} className="flex items-center justify-between p-3 bg-slate-800 rounded text-sm">
                        <div className="flex items-center gap-3">
                          <span className={`font-bold px-2 py-1 rounded ${
                            trade.type === 'BUY' ? 'bg-green-600/20 text-green-500' : 'bg-red-600/20 text-red-500'
                          }`}>
                            {trade.type}
                          </span>
                          <span className="font-semibold">{trade.crypto}</span>
                        </div>
                        <div className="text-right">
                          <div className="font-semibold">${trade.amount.toFixed(2)}</div>
                          <div className="text-xs text-slate-500">
                            {trade.quantity.toFixed(6)} @ ${trade.price.toFixed(2)}
                          </div>
                        </div>
                      </div>
                    ))
                  )}
                </div>
              </div>
            </div>

            <div className="lg:col-span-3">
              <div className="bg-slate-900 p-4 rounded-lg border border-slate-800">
                <h3 className="font-semibold mb-4">Top Crypto</h3>
                <div className="max-h-[700px] overflow-y-auto space-y-2">
                  {cryptoData.map(crypto => (
                    <div
                      key={crypto.id}
                      onClick={() => setSelectedCrypto(crypto.id)}
                      className={`p-3 rounded cursor-pointer transition-all ${
                        selectedCrypto === crypto.id 
                          ? 'bg-blue-600/20 border border-blue-600' 
                          : 'bg-slate-800 hover:bg-slate-700'
                      }`}
                    >
                      <div className="flex items-center justify-between mb-1">
                        <div className="flex items-center gap-2">
                          <img src={crypto.image} alt={crypto.name} className="w-6 h-6" />
                          <span className="font-semibold text-sm">{crypto.symbol.toUpperCase()}</span>
                        </div>
                        <span className="text-xs text-slate-400">#{crypto.market_cap_rank}</span>
                      </div>
                      <div className="flex items-center justify-between">
                        <span className="text-sm font-semibold">${crypto.current_price?.toFixed(2) || '0.00'}</span>
                        <span className={`text-xs ${(crypto.price_change_percentage_24h || 0) >= 0 ? 'text-green-500' : 'text-red-500'}`}>
                          {(crypto.price_change_percentage_24h || 0) >= 0 ? '↗' : '↘'} {Math.abs(crypto.price_change_percentage_24h || 0).toFixed(2)}%
                        </span>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            </div>
          </div>
        )}

        {activeTab === 'wallet' && wallet && (
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
            <div className="bg-slate-900 p-6 rounded-lg border border-slate-800">
              <h3 className="font-semibold mb-6 text-xl flex items-center gap-2">
                <Shield size={24} className="text-blue-500" />
                Informations Wallet
              </h3>
              <div className="space-y-4">
                <div>
                  <label className="text-sm text-slate-400 block mb-2 flex items-center gap-2">
                    <Wallet size={16} />
                    Adresse
                  </label>
                  <div className="flex gap-2">
                    <input 
                      type="text" 
                      value={wallet.address}
                      readOnly
                      className="flex-1 bg-slate-800 border border-slate-700 rounded px-3 py-2 text-sm font-mono"
                    />
                    <button
                      onClick={() => copyToClipboard(wallet.address)}
                      className="p-2 bg-blue-600 hover:bg-blue-700 rounded"
                    >
                      <Copy size={16} />
                    </button>
                  </div>
                </div>

                <div>
                  <label className="text-sm text-slate-400 block mb-2 flex items-center gap-2">
                    <Key size={16} />
                    Clé Publique
                  </label>
                  <div className="flex gap-2">
                    <input 
                      type="text" 
                      value={wallet.publicKey}
                      readOnly
                      className="flex-1 bg-slate-800 border border-slate-700 rounded px-3 py-2 text-sm font-mono"
                    />
                    <button
                      onClick={() => copyToClipboard(wallet.publicKey)}
                      className="p-2 bg-blue-600 hover:bg-blue-700 rounded"
                    >
                      <Copy size={16} />
                    </button>
                  </div>
                </div>

                <div>
                  <label className="text-sm text-slate-400 block mb-2 flex items-center gap-2">
                    <Key size={16} className="text-red-500" />
                    Clé Privée
                    <span className="text-red-500 text-xs">(NE JAMAIS PARTAGER)</span>
                  </label>
                  <div className="flex gap-2">
                    <input 
                      type={showPrivateKey ? 'text' : 'password'}
                      value={wallet.privateKey}
                      readOnly
                      className="flex-1 bg-slate-800 border border-red-700 rounded px-3 py-2 text-sm font-mono"
                    />
                    <button
                      onClick={() => setShowPrivateKey(!showPrivateKey)}
                      className="p-2 bg-slate-700 hover:bg-slate-600 rounded"
                    >
                      {showPrivateKey ? <EyeOff size={16} /> : <Eye size={16} />}
                    </button>
                    <button
                      onClick={() => copyToClipboard(wallet.privateKey)}
                      className="p-2 bg-red-600 hover:bg-red-700 rounded"
                    >
                      <Copy size={16} />
                    </button>
                  </div>
                </div>

                <div>
                  <label className="text-sm text-slate-400 block mb-2">
                    Phrase de Récupération (12 mots)
                    <span className="text-red-500 text-xs ml-2">(NE JAMAIS PARTAGER)</span>
                  </label>
                  <div className="bg-slate-800 border border-red-700 rounded p-4">
                    {showSeedPhrase ? (
                      <div className="grid grid-cols-3 gap-2 mb-4">
                        {wallet.seedPhrase.split(' ').map((word, i) => (
                          <div key={i} className="bg-slate-900 px-3 py-2 rounded text-sm font-mono">
                            {i + 1}. {word}
                          </div>
                        ))}
                      </div>
                    ) : (
                      <div className="text-center py-4 text-slate-500">
                        <Key className="mx-auto mb-2" size={24
